# Подготовка к собеседованию

## 1. SWEBOK

**SWEBOK (software engineering body of knowledge)** - основной научно-технический документ по программной инженерии,
отображающий знания и накопленный опыт специалистов по программной инженерии.

---

Ядру знаний SWEBOK соответствует стандарт ISO/IEC TR 19759:2005.

Основные области знаний SWEBOK:

- Инженерия требований (определение, анализ, спецификация, проверка)123
- Проектирование ПО (ключевые вопросы, архитектура, нотации, стратегия)
- Конструирование ПО (снижение сложности, валидация, внешние стандарты).
- Тестирование ПО (уровни тестирования, техники, метрики, управление тест.)
- Сопровождение ПО (концепция, ключевые вопросы)

## 2. ОСНОВЫ ТЕСТИРОВАНИЯ

**Тестирование программного обеспечения** — проверка соответствия между реальным и ожидаемым поведением программы,
осуществляемая на конечном наборе тестов, выбранном определенным образом. В более широком смысле тестирование — это одна
из техник контроля качества, включающая в себя активности по планированию работ (Test Management), проектированию
тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).

---

**Тестирование программного обеспечения** — проверка соответствия между реальным и ожидаемым поведением программы,
осуществляемая на конечном наборе тестов, выбранном определенным образом. В более широком смысле тестирование — это одна
из техник контроля качества, включающая в себя активности по планированию работ (Test Management), проектированию
тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).

**Этапы тестирования:**

1. Анализ продукта
2. Работа с требованиями
3. Разработка стратегии тестирования и планирование процедур контроля качества
4. Создание тестовой документации
5. Тестирование прототипа
6. Основное тестирование
7. Стабилизация
8. Эксплуатация

**Тест** - набор входных данных и прочих условий, которые полностью определяют ход выполнения программы.

**Тестовый сценарий (Test Case)** — это артефакт, описывающий совокупность шагов, условий и параметров, необходимых для
проверки тестируемой функции или её части.

**Чек-лист (check list)** — это документ, описывающий что должно быть протестировано.

**Дефект (баг, bug)** – это несоответствие фактического результата выполнения программы ожидаемому результату.

**Баг Репорт (Bug Report)** — это документ, описывающий ситуацию или последовательность действий, приведшую к
некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.

**Цель тестирования** - локализация и устранение дефектов, соответствующие всем сбоям программы, обнаруженным с помощью
тестов.

**Сопровождение ПО** - совокупность действий по обеспечению работы ПО, внесению изменений при выявлении ошибок,
адаптации к новой среде исполнения, улучшения продуктивности или других характеристик ПО.

**Тест план (Test Plan)** — это документ, описывающий весь объем работ по тестированию, начиная с описания объекта,
стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования,
специальных знаний, а также оценки рисков с вариантами их разрешения.

**Верификация (verification)** — это процесс оценки системы или её компонентов с целью определения удовлетворяют ли
результаты текущего этапа разработки условиям, сформированным в начале этого этапа. Верификация (verification) — это
требования.

**Валидация (validation)** — это определение соответствия разрабатываемого ПО ожиданиям и потребностям пользователя,
требованиям к системе. Валидация (validation) – это нужны заказчика.

**QC (контроль качества)** – процесс направленных на контроль текущего качества продукта и сравнение его с задуманными
характеристиками. ЗА КАЧЕСТВО.

**QA (гарантия качества)** – глобальные задачи, анализ работы тестировщика и QC. ЗА КАЧЕСТВО ПОСТРОЕНИЕ ПРОЦЕССА.

## 3. МЕТОДЫ ТЕСТИРОВАНИЯ

Особым методом исследования управления, наиболее популярным в современных условиях и достаточно эффективным, является
метод тестирования.

---

**Белый ящик** - структурное тестирование тестирование внутренних структур и операций ПО.

- Виды: тестирование API, внедрение ошибок, покрытие кода, мутационное тестирование, статическое тестирование.

**Черный ящик** - тестирование функциональности, доступной конечному пользователю ПО.

- Виды: анализ граничных значений, таблицы принятия решений, тестирование прецедентов, тестирование потоков данных и т.
  д.

**Серый ящик** - тестирование ПО с частичным знанием о его внутренней структуре.

- Виды: тестирование интерфейсов компонентов системы, анализ обработки ошибок

## 4. ТЕСТ - ДИЗАЙН

**Тест дизайн** – это этап процесса тестирования ПО, на котором проектируются и создаются тестовые сценарии (тест кейсы)
, в соответствии с определёнными ранее критериями качества и целями тестирования.

---

**Тест дизайн** – это этап процесса тестирования ПО, на котором проектируются и создаются тестовые сценарии (тест кейсы)
, в соответствии с определёнными ранее критериями качества и целями тестирования.

- **Эквивалентное Разделение (Equivalence Partitioning — EP)**. Как пример, у вас есть диапазон допустимых значений от 1
  до 10, вы должны выбрать одно верное значение внутри интервала, скажем, 5, и одно неверное значение вне интервала — 0.
- **Анализ Граничных Значений (Boundary Value Analysis — BVA)**. Если взять пример выше, в качестве значений для
  позитивного тестирования выберем минимальную и максимальную границы (1 и 10), и значения больше и меньше границ (0 и
  11). Анализ Граничный значений может быть применен к полям, записям, файлам, или к любого рода сущностям, имеющим
  ограничения.
- **Причина / Следствие (Cause/Effect — CE)**. Это, как правило, ввод комбинаций условий (причин), для получения ответа
  от системы (Следствие). Например, вы проверяете возможность добавлять клиента, используя определенную экранную форму.
  Для этого вам необходимо будет ввести несколько полей, таких как «Имя», «Адрес», «Номер Телефона» а затем, нажать
  кнопку «Добавить» — это «Причина». После нажатия кнопки «Добавить», система добавляет клиента в базу данных и
  показывает его номер на экране — это «Следствие».
- **Предугадывание ошибки (Error Guessing — EG)**. Это когда тестировщик использует свои знания системы и способность к
  интерпретации спецификации на предмет того, чтобы «предугадать» при каких входных условиях система может выдать
  ошибку. Например, спецификация говорит: «пользователь должен ввести код». Тестировщик будет думать: «Что, если я не
  введу код?», «Что, если я введу неправильный код?», и так далее. Это и есть предугадывание ошибки.
- **Исчерпывающее тестирование (Exhaustive Testing — ET)** — это крайний случай. В пределах этой техники вы должны
  проверить все возможные комбинации входных значений, и в принципе, это должно найти все проблемы. На практике
  применение этого метода не представляется возможным, из-за огромного количества входных значений.
- **Попарное тестирование (Pairwise Testing)** — это техника формирования наборов тестовых данных. Сформулировать суть
  можно, например, вот так: формирование таких наборов данных, в которых каждое тестируемое значение каждого из
  проверяемых параметров хотя бы единожды сочетается с каждым тестируемым значением всех остальных проверяемых
  параметров.

## 5. УРОВНИ ТЕСТИРОВАНИЯ

Тестирование на разных уровнях производится на протяжении всего жизненного цикла разработки и сопровождения программного
обеспечения. Уровень тестирования определяет то, над чем производятся тесты: над отдельным модулем, группой модулей или
системой, в целом. Проведение тестирования на всех уровнях системы - это залог успешной реализации и сдачи проекта.

---

1. Модульное тестирование (Unit Testing). Компонентное (модульное) тестирование проверяет функциональность и ищет
   дефекты в частях приложения, которые доступны и могут быть протестированы по-отдельности (модули программ, объекты,
   классы, функции и т.д.).

2. Интеграционное тестирование (Integration Testing) . Проверяется взаимодействие между компонентами системы после
   проведения компонентного тестирования.
3. Системное тестирование (System Testing). Основной задачей системного тестирования является проверка как
   функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты, такие как неверное
   использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с
   окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство
   использования и т.д.
4. Операционное тестирование (Release Testing). Убедиться, что система удовлетворяет нуждам пользователя и выполняет
   свою роль в среде своей эксплуатации, как это было определено в бизнес моделе системы. Следует учесть, что и бизнес
   модель может содержать ошибки. Поэтому так важно провести операционное тестирование как финальный шаг валидации.
   Кроме этого, тестирование в среде эксплуатации позволяет выявить и нефункциональные проблемы, такие как: конфликт с
   другими системами, смежными в области бизнеса или в программных и электронных окружениях; недостаточная
   производительность системы в среде эксплуатации и др.
5. Приемочное тестирование (Acceptance Testing). Формальный процесс тестирования, который проверяет соответствие системы
   требованиям и проводится с целью:
    - определения удовлетворяет ли система приемочным критериям;
    - вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.

## 6. ВИДЫ И ТИПЫ ТЕСТИРОВАНИЯ

Существует очень много видов тестирования которые различают и для которых придумали свои определения, с большинством из
существующих типов вы возможно и не столкнетесь на работе, но знать о них нужно как для собеседований, так и для общего
развития в сфере тестирования.

---

**Функциональное тестирование** рассматривает заранее указанное поведение и основывается на анализе спецификаций
функциональности компонента или системы в целом.

**Тестирование пользовательского интерфейса (GUI Testing)** — функциональная проверка интерфейса на соответствие
требованиям — размер, шрифт, цвет, consistent behavior.

**Тестирование безопасности** — это стратегия тестирования, используемая для проверки безопасности системы, а также для
анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов,
несанкционированного доступа к конфиденциальным данным.

**Тестирование взаимодействия (Interoperability Testing)** – это функциональное тестирование, проверяющее способность
приложения взаимодействовать с одним и более компонентами или системами и включающее в себя тестирование совместимости (
compatibility testing) и интеграционное тестирование

**Нагрузочное тестирование** — это автоматизированное тестирование, имитирующее работу определенного количества бизнес
пользователей на каком-либо общем (разделяемом ими) ресурсе.

**Стрессовое тестирование (Stress Testing)** позволяет проверить насколько приложение и система в целом работоспособны в
условиях стресса и также оценить способность системы к регенерации, т.е. к возвращению к нормальному состоянию после
прекращения воздействия стресса. Стрессом в данном контексте может быть повышение интенсивности выполнения операций до
очень высоких значений или аварийное изменение конфигурации сервера.

**Объемное тестирование (Volume Testing)**. Задачей объемного тестирования является получение оценки производительности
при увеличении объемов данных в базе данных приложения

**Тестирование стабильности или надежности (Stability / Reliability Testing)**. Задачей тестирования стабильности (
надежности) является проверка работоспособности приложения при длительном (многочасовом) тестировании со средним уровнем
нагрузки.

**Тестирование установки** направленно на проверку успешной инсталляции и настройки, а также обновления или удаления
программного обеспечения.

**Тестирование удобства пользования** — это метод тестирования, направленный на установление степени удобства
использования, обучаемости, понятности и привлекательности для пользователей разрабатываемого продукта в контексте
заданных условий. Сюда также входит:

**User eXperience (UX)** — ощущение, испытываемое пользователем во время использования цифрового продукта, в то время
как User interface — это инструмент, позволяющий осуществлять интеракцию «пользователь — веб-ресурс».

**Тестирование на отказ и восстановление (Failover and Recovery Testing)** проверяет тестируемый продукт с точки зрения
способности противостоять и успешно восстанавливаться после возможных сбоев, возникших в связи с ошибками программного
обеспечения, отказами оборудования или проблемами связи (например, отказ сети). Целью данного вида тестирования является
проверка систем восстановления (или дублирующих основной функционал систем), которые, в случае возникновения сбоев,
обеспечат сохранность и целостность данных тестируемого продукта.

**Конфигурационное тестирование (Configuration Testing)** — специальный вид тестирования, направленный на проверку
работы программного обеспечения при различных конфигурациях системы (заявленных платформах, поддерживаемых драйверах,
при различных конфигурациях компьютеров и т.д.)

**Дымовое (Smoke) тестирование** рассматривается как короткий цикл тестов, выполняемый для подтверждения того, что после
сборки кода (нового или исправленного) устанавливаемое приложение, стартует и выполняет основные функции.

**Регрессионное тестирование** — это вид тестирования направленный на проверку изменений, сделанных в приложении или
окружающей среде (починка дефекта, слияние кода, миграция на другую операционную систему, базу данных, веб сервер или
сервер приложения), для подтверждения того факта, что существующая ранее функциональность работает как и прежде.
Регрессионными могут быть как функциональные, так и нефункциональные тесты.

**Повторное тестирование** — тестирование, во время которого исполняются тестовые сценарии, выявившие ошибки во время
последнего запуска, для подтверждения успешности исправления этих ошибок.

В чем разница между regression testing и re-testing?

**Re-testing** — проверяется исправление багов

**Regression testing** — проверяется то, что исправление багов, а также любые изменения в коде приложения, не повлияли
на другие модули ПО и не вызвало новых багов.

**Тестирование сборки или Build Verification Test** — тестирование направленное на определение соответствия, выпущенной
версии, критериям качества для начала тестирования. По своим целям является аналогом Дымового Тестирования,
направленного на приемку новой версии в дальнейшее тестирование или эксплуатацию. Вглубь оно может проникать дальше, в
зависимости от требований к качеству выпущенной версии.

**Санитарное тестирование** — это узконаправленное тестирование достаточное для доказательства того, что конкретная
функция работает согласно заявленным в спецификации требованиям. Является подмножеством регрессионного тестирования.
Используется для определения работоспособности определенной части приложения после изменений, произведенных в ней или
окружающей среде. Обычно выполняется вручную.

**Статическое тестирование** — это тип метода тестирования программного обеспечения, который выполняется для проверки
дефектов в программном обеспечении без фактического выполнения кода программного приложения.

**Динамическое тестирование** – это тестирование, при котором выполняется код программы.

**Матрица соответствия требований** — это двумерная таблица, содержащая соответсвие функциональных требований (
functional requirements) продукта и подготовленных тестовых сценариев (test cases). (это двумерная таблица, которую
строят на основе требований и проверяют, что требования покрыты техниками тест-дизайна.

**ФУНКЦИОНАЛЬНЫЕ ВИДЫ ТЕСТИРОВАНИЯ**:

- Функциональное тестирование.
- Тестирование пользовательского интерфейса.
- Тестирование безопасности.
- Тестирование взаимодействия.

**НЕФУНКЦИОНАЛЬНЫЕ ВИДЫ ТЕСТИРОВАНИЯ**:

- Все виды тестирования производительности:
- Нагрузочное, Стрессовое, Стабильность и надёжность.
- Тестирование установки.
- Тестирование удобства пользования.
- Тестирование на отказ и восстановление.
- Конфигурационное тестирование.
- SDLC – Software Development Life Cycle (жизненный цикл разработки ПО)
- Анализ требований
- Проектирование и архитектура
- Разработка и реализация
- Тестирование
- Выпуск/релиз и внедрение
- Поддержка

## 7. ПРОЦЕССЫ РАЗРАБОТКИ

**Процесс разработки программного обеспечения** — структура, согласно которой построена разработка программного
обеспечения (ПО).

---

**Scrum** - это каркас разработки, с использованием которого люди могут решать появляющиеся проблемы, при этом
продуктивно и производя продукты высочайшей значимости. В Scrum основное значение имеет команда. Она
кросс-функциональна, то есть собирается из разных специалистов.

**В основе такого типа** — непродолжительные ежедневные встречи — «Scrum» и регулярно повторяющиеся собрания (раз в
неделю, раз в две недели или раз в месяц), которые называются «Sprint». На ежедневных совещаниях участники команды
обсуждают:

- отчёт о проделанной работе с момента последнего Scrum’a;
- список задач, которые сотрудник должен выполнить до следующего собрания;
- затруднения, возникшие в ходе работы.

**Scrum** опирается на **Agile**. ОТЛИЧИЯ:

**AGILE** определяет ценности и принципы, которым руководствуются участники команд. **SCRUM** это уже фреймворк для
управления проектами.
**AGILE** это общие рекомендации. **SCRUM** находится внутри **AGILE** и содержит конкретные правила для управления
проектами.

**Роли в Scrum:**

**В классическом Scrum существует 3 базовых роли:**

- **Product owner (владелец продукта)** - (является связующим звеном между командой разработки и заказчиком. Задача РО —
  максимальное увеличение ценности разрабатываемого продукта и работы команды.)
- **Scrum master - (является «служащим лидером».)** - Задача Scrum Master — помочь команде максимизировать ее
  эффективность посредством устранения препятствий, помощи, обучении и мотивации команде, помощи PO).
- **Команда разработки (Development team)** - (состоит из специалистов, производящих непосредственную работу над
  производимым продуктом).

**Другие сущности в Scrum:**

**Product-бэклог** — это полный список всех работ, при реализации которых мы получим конечный продукт.

**Спринт-бэклог** — это список работ, который определила команда и согласовала с Владельцем продукта, на ближайший
отчетный период (спринт). Задания в спринт-бэклог берутся из product-бэклога.

**Спринт** — отрезок времени, который берется для выполнения определенного (ограниченного) списка задач. Рекомендуется
брать 2-4 недели (длительность определяется командой один раз).

**Планирование спринта** — это совещание, на котором присутствуют все (команда, Scrum-мастер, Владелец продукта). В
течение этого совещания Владелец продукта определяет приоритеты заданий, которые он хотел бы увидеть выполненными по
истечении спринта.

При разработке ПО **SCRUM канбан-доска** обычно включает следующие колонки в соответствии со статусом задач:
обсуждается (backlog), согласовано (ready), кодируется (coding), тестируется (testing), подтверждается (approval) и
сделано (done). На доску в соответствующий столбец прикрепляются канбан-карточки.

**Ретроспектива** - одна из регулярных встреч для команд, которые работают по Scrum, наряду с ежедневными стенд-апами (
scrum meeting или daily meeting) и планированием спринта

## 8. МЕТОДОЛОГИИ РАЗРАБОТКИ

**Методология разработки ПО** – это процесс описания того, как определенный продукт будет разрабатываться, то есть один
из способов организации коллективной разработки.

---

**«Waterfall Model» (каскадная модель или «водопад»)** - подразумевает последовательное прохождение стадий, каждая из
которых должна завершиться полностью до начала следующей. Используется, когда:

- Только тогда, когда требования известны, понятны и зафиксированы. Противоречивых требований не имеется.
- Нет проблем с доступностью программистов нужной квалификации.
- В относительно небольших проектах.

**«Agile Model» (гибкая методология разработки)** - Методология подходит для больших или нацеленных на длительный
жизненный цикл проектов, постоянно адаптируемых к условиям рынка. Соответственно, в процессе реализации требования
изменяются. Использовать, когда:

- Когда потребности пользователей постоянно меняются в динамическом бизнесе.
- Изменения на Agile реализуются за меньшую цену из-за частых инкрементов.
- В отличие от модели водопада, в гибкой модели для старта проекта достаточно лишь небольшого планирования.

**RUP (Rational Unified Process)** - (методология разработки ПО, созданная компанией Rational Software)

**Основные принципы:**

1. ранняя идентификация и непрерывное (до окончания проекта) устранение основных рисков
2. концентрация на выполнении требований заказчиков к исполняемой программе
3. ожидание изменений в требованиях, проектных решениях и реализации в процессе разработки
4. компонентная архитектура, реализуемая и тестируемая на ранних стадиях проекта
5. постоянное обеспечение качества на всех этапах разработки проекта (продукта)
6. работа над проектом в сплочённой команде, ключевая роль в которой принадлежит архитекторам

**Начальная стадия (Inception)**

В фазе начальной стадии:
Формируются видение и границы проекта. Создается экономическое обоснование (business case). Определяются основные
требования, ограничения и ключевая функциональность продукта. Создается базовая версия модели прецедентов.
(Прецедент соответствует отдельной функциональности системы, определяет один из вариантов её использования и описывает
типичный способ взаимодействия пользователя с системой. Варианты использования обычно применяются для спецификации
внешних требований к системе)
Оцениваются риски. При завершении начальной фазы оценивается достижение этапа жизненного цикла цели, которое
предполагает соглашение заинтересованных сторон о продолжении проекта.

**Уточнение (Elaboration)**

В фазе «Уточнение» производится анализ предметной области и построение исполняемой архитектуры. Это включает в себя:
Документирование требований (включая детальное описание для большинства прецедентов). Спроектированную, реализованную и
оттестированную исполняемую архитектуру. Обновленное экономическое обоснование и более точные оценки сроков и стоимости.
Сниженные основные риски. Успешное выполнение фазы разработки означает достижение этапа жизненного цикла архитектуры

**Построение (Construction)**

В фазе «Построение» происходит реализация большей части функциональности продукта. Фаза Построение завершается первым
внешним релизом системы и вехой начальной функциональной готовности.

**Внедрение (Transition)**

В фазе «Внедрение» создается финальная версия продукта и передается от разработчика к заказчику. Это включает в себя
программу бета-тестирования, обучение пользователей, а также определение качества продукта. В случае, если качество не
соответствует ожиданиям пользователей или критериям, установленным в фазе Начало, фаза Внедрение повторяется снова.
Выполнение всех целей означает достижение вехи готового продукта и завершение полного цикла разработки.

## 9. РОЛИ В IT

- Бизнес-аналитик (BA)
- Менеджер (ресурсы, время)
- Program manger (технический менеджер)
- Recourse manager(hr) – развитие людей.
- Программист
- Тестировщик
- DevOps – среда разработки, мониторинг.

## 10. ПРОГРАММИРОВАНИЕ

**Программи́рование** — процесс создания компьютерных программ.

---

**ООП (Объектно-ориентированное программирование)** — это парадигма разработки программных систем, в которой приложения
состоят из объектов. Объекты — это сущности, у которых есть свойства и поведение.

1. **Наследование** (позволяет описать новый класс на основе существующего (родительского). При этом свойства и
   функциональность родительского класса заимствуются новым классом).
2. **Абстракция** (Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот —
   отбрасывание второстепенных, незначительных)
3. **Инкапсуляция** (Инкапсуляция означает ограничение доступа к данным и возможностям их изменения).
4. **Полиморфизм** (это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение
   объектов будет разным в зависимости от типа, к которому они принадлежат).

**Понятия в программировании:**

**Ветвление (условная инструкция)** - это конструкция языка программирования, обеспечивающая выполнение определённой
команды или набора команд только при условии истинности некоторого логического выражения, либо выполнение одной из
нескольких команд (наборов команд) в зависимости от значения некоторого выражения.

**Цикл** — это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора
инструкций. (while – простая структура цикла и уже не популярны, for – более сложный и гибкий цикл, сейчас везде
используется).

**Массив** - структура данных в виде набора компонентов (элементов массива), расположенных в памяти непосредственно друг
за другом.

**Стек** - абстрактный тип данных, представляющий собой список элементов, организованных по принципу «последним пришёл —
первым вышел»).

**Очереди** - абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»

**Дерево** — это способ организации данных в виде иерархической структуры.

**Хеш-функция**, или функция свёртки — функция, осуществляющая преобразование массива входных данных произвольной длины
в (выходную) битовую строку установленной длины, выполняемое определённым алгоритмом.

**Программирование графами** это метод создания реальных работающих программ с использованием ориентированных графов.

## 11. GIT

**Git** — распределённая система управления версиями.

---

**GITGUB/GITLAB/BITBUCKET** — это платформа управления Git-репозиториями, анализа кода, отслеживания ошибок,
тестирования, ведения каналов и вики-страниц.

**Репозиторий** — это хранилище — место, где хранятся и поддерживаются какие-либо данные.

**git-flow** – это набор расширений git, предоставляющий высокоуровневые операции над репозиторием.

**Команды GIT:**

- **git add** - добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита(подготовка
  файлов/пакета). По умолчанию git commit использует лишь этот индекс, можно использовать git add для сборки следующего
  коммита.
- **git push** – внести изменения в удаленный репозиторий.
- **git status** - показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в
  индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.
- **git diff** - используется для вычисления разницы между любыми двумя Git деревьями.
- **git difftool** - запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите
  использовать что-либо отличное от встроенного просмотрщика git diff.
- **git commit** - берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе
  данных, а затем сдвигает указатель текущей ветки на этот слепок.
- **git reset** - как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель
  HEAD и, опционально, состояние индекса.
- **git rm** - используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на git add с тем лишь
  исключением, что она удаляет, а не добавляет файлы для следующего коммита.
- **git mv** — это всего лишь удобный способ переместить файл, а затем выполнить git add для нового файла и git rm для
  старого.
- **git clean** - используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или
  файлы конфликтов слияний.
- **git merge** – команда служит для слияния веток. (Например, в проекте требуется пофиксить баг – обычно это выполняют
  в отдельной ветке, а потом сливают в основную ветку master.).

## 12. МИКРОСЕРВИСНАЯ АРХИТЕКТУРА, ВИДЫ АРХИТЕКТУРЫ

**Микросервисная архитектура** — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на
взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов, получивший
распространение в середине 2010-х годов в связи с развитием практик гибкой разработки и DevOps.

---

**SOA (Service-oriented architecture)** - связывает между собой команды и организации

**MSA (Measurement System Analysis, анализ измерительных систем)** - это метод, призванный дать заключение относительно
приемлемости используемой измерительной системы через количественное выражение её характеристик. Под измерительными
системами понимаются совокупность приборов, стандартов, операций, методов, персонала, компьютерных программ, окружающей
среды, используемых для придания количественных значений измеряемым величинам.

**Архитектурный стиль микросервисов** — это подход, при котором единое приложение строится как набор небольших сервисов,
каждый из которых работает в собственном процессе и коммуницирует с остальными используя легковесные механизмы, как
правило HTTP. Эти сервисы построены вокруг бизнес-потребностей и развертываются независимо с использованием полностью
автоматизированной среды. Существует абсолютный минимум централизованного управления этими сервисами. Сами по себе эти
сервисы могут быть написаны на разных языках и использовать разные технологии хранения данных.

**Микросервисная архитектура** наследует от предшественницы изоляцию и распределённость. Здесь база данных не
используется как шина данных, за исключением отдельных случаев в пользу производительности. По классической схеме
компоненты изолируются и на уровне кода, и на уровне базы.

**Монолитный сервер** – вариант архитектуры. довольно очевидный способ построения подобных систем. Вся логика по
обработке запросов выполняется в единственном процессе, при этом вы можете использовать возможности вашего языка
программирования для разделения приложения на классы, функции и namespace-ы. Вы можете запускать и тестировать
приложение на машине разработчика и использовать стандартный процесс развертывания для проверки изменений перед
выкладыванием их в продакшн. Вы можете масштабировать монолитное приложения горизонтально путем запуска нескольких
физических серверов за балансировщиком нагрузки.

**Виды:**

**Unit-тестирование** - количество unit — тестов является наибольшим среди всех остальных. Принципы и подходы ничем не
отличаются от unit — тестирования обычных приложений. Стек используемых технологий зависит от языка, на котором написан
данный микросервис.

**Контракт** — это служебный вызов сервиса, при тестировании проверяется ответ или другой результат, которые зависят от
входных данных. Каждый потребитель должен получать один и тот же результат от сервисов, даже если его внутренняя
реализация изменяется. Каждый сервис должен быть способен к гибкому изменению функционала, но ранее реализованный
функционал не должен меняться и тянуть за собой изменение вызывающего сервиса.

**Интеграционное тестирование** - при интеграционном тестирование проверяется корректность взаимодействия различных
микросервисов друг с другом. Это один из самых критичных тестов всей архитектуры. При положительном исходе тестирования
мы можем быть уверены, что вся архитектура спроектирована верно и все независимые микросервисы функционируют как единое
целое в соответствии с ожиданиями.

**End-to-end** - Данное тестирование позволяет проверить корректность взаимодействия микросервисов и других служб,
например, базы данных.

**UI —** это завершающий вид тестирования. Проверяется почти то же самое, что и при end-to-end тестировании, но только с
использованием UI. Может проводиться мануальными тестировщиками или с помощью автотестов.

**Микросервисная архитектура в тестировании** - традиционно принято считать, что тестирование производится перед
релизом. В некоторых компаниях были — и существуют поныне — отдельные команды тестировщиков (QA), главной обязанностью
которых является выполнение ручных или автоматизированных тестов для ПО, созданного командами разработки. Как только
компонент ПО проходит QA, его передают команде эксплуатации для запуска (в случае сервисов), или же релизят в виде
продукта (в случае десктоп-приложений и игр).

Эта модель медленно, но верно уходит в прошлое — по крайней мере, в отношении сервисов; на сколько я могу судить по
стартапам в Сан-Франциско. Теперь команды разработчиков отвечают и за тестирование, и за эксплуатацию сервисов, которые
они создают. Этот новый подход к созданию сервисов я нахожу невероятно мощным — он по-настоящему позволяет командам
разработчиков думать о масштабе, целях, компромиссах и компенсациях на всем спектре методов тестирования — причем в
реалистической манере. Для того чтобы всецело разобраться, как функционируют наши сервисы, и удостовериться в
корректности их работы, нам очевидно требуется возможность выбора правильного подмножества методов тестирования и
инструментов с учетом требуемых параметров доступности, надежности и корректности работы сервиса.

## 13. WEB + УРОВНИ ПЕРЕДАЧИ ДАННЫХ

**OSI (Open Systems Interconnection)** — это скелет, фундамент и база всех сетевых сущностей. Модель определяет сетевые
протоколы, распределяя их на 7 логических уровней. Важно отметить, что в любом процессе, управление сетевой передачей
переходит от уровня к уровню, последовательно подключая протоколы на каждом из уровней.

---

**Интерфейс** - в информатике рассматривается как общая граница двух отдельно существующих составных частей, посредством
которой они обмениваются информацией в режиме одновременности. Этот обмен может быть, как двусторонним, так и
односторонним.

**Протокол** - набор соглашений интерфейса логического уровня. Эти соглашения задают единообразный способ передачи
сообщений и обработки ошибок при взаимодействии программного обеспечения разнесённой в пространстве аппаратуры,
соединённой тем или иным интерфейсом.

**OSI (Open Systems Interconnection)** — это скелет, фундамент и база всех сетевых сущностей. Модель определяет сетевые
протоколы, распределяя их на 7 логических уровней. Важно отметить, что в любом процессе, управление сетевой передачей
переходит от уровня к уровню, последовательно подключая протоколы на каждом из уровней.

**IP - транспортный протокол**

**IP** - протокол предназначен для обмена данными между сетями и содержит в себе информации о сетевом протоколе.

- Ipv6 – свежая версия протокола IP (128 бит в виде восьми 16-битных полей)
- Ipv4 – классическая версия протокола IP (32 бита, запись в виде четырёх десятич. чисел от 0 до 255)

**UDP** - протокол транспортного уровня. Он тоже базируется на IP и тоже использует порты, но в отличие от TCP он не
устанавливает соединений и не требует подтверждения получения каждого пакета. Быстро, но без гарантии доставки.

**TCP** - даёт уверенность в безошибочности получаемых данных. один из основных протоколов передачи данных интернета,
предназначенный для управления передачей данных. TCP – сетевой. (проверяет целостность байтов).

**PPP** – двухточечный протокол канального уровня (data link). Используется для установления прямой связи между двумя
связями сети.

**SCTP** – (Stream Control Transmission Protocol — «протокол передачи с управлением потоком») — протокол транспортного
уровня в компьютерных сетях, появившийся в 2000 году.

**HTTP** - протокол передачи гипертекста.

**HTTPS** – расширение протокола http для поддержки шифрования (выше безопасность).

**SMTP** – протокол пересылки почти (TCP-порт 25).

**FTP** – соединение двух узлов начинается с рукопожатия. протокол передачи файлов (TCP-порт 21).

**Сетевой порт** — это сетевой ресурс, отображаемый в виде числа (1-65535), которое определяет назначение входящих или
исходящих сетевых потоков данных на заданном устройстве.

**PAP (Password Authentication Protocol)** — протокол простой проверки подлинности, предусматривающий отправку имени
пользователя и пароля на сервер удалённого доступа открытым текстом (без шифрования).

**RPC (Remote Procedure Call, удалённый вызов процедур)** - класс технологий, позволяющих компьютерным программам
вызывать функции или процедуры в другом адресном пространстве.

**ASCII (American Standard Code for Information Interchange)** – Стандартный американский код обмена информацией) – это
код для представления. символов в виде чисел, в котором каждому символу сопоставлено число от 0 до 127.

**Уровни OSI:**

1. **Физический** – передача битов по физическому каналу связи. Не вникает в смысл передаваемой информации. Задача:
   представить биты информации в виде сигналов, передаваемых по среде.
2. **Канальный** – передача сообщений по каналу связи. Определение начала/конца сообщения в потоке бит. Обнаружение и
   коррекция ошибок. В широковещательной сети (Управление доступом к среде передачи данных. Физическая адресация).
3. **Сетевой** – построение крупных составных сетей на основе различных сетевых технологий. (Адресация обеспечивается,
   определяется компьютер. Определение маршрута пересылки пакетов в составной сети – маршрутизация).
4. **Транспортный** – обеспечивается передачу данных между процессами на хостах. Управление надежностью. Является
   сквозным (сообщение доставляются от источника адресату. Предыдущие уровни используют принцип звеньев цепи).
5. **Сеансовый** – позволяет устанавливать сеансы связи. (Управление диалогом – очередность передачи сообщений).
   Управление маркерами (предотвращение одновременного выполнения критичной операции). Синхронизация (метки в сообщениях
   для возобновления передачи в случаях сбоя).
6. **Представления** – обеспечивает согласование синтаксиса и семантики передаваемых данных. (форматы представления
   символов, чисел). Пример: автоматический перевод.
7. **Прикладной** – набор приложений, полезных пользователям. (skype, видео и аудио связь, соц. сети, электронная почта)
   .

## 14. ИНТЕРНЕТ ЗАПРОСЫ

**DHCP (dynamic host configuration protocol)** – сервис, который позволяет устройству в сети динамически получать IP
адрес и некоторые настройки сети от центрального сервера. Если компьютер настроен на динамическое получения IP адреса,
то при загрузке он будет отправлять широковещательные запросы, в надежде, что ему ответит DHCP сервер.

**DNS (Domain Name System, система доменных имен)** – сервис, разрешающий доменные имена в IP адреса. Например, при
обращении к ресурсам Интернет в поле URL мы вбиваем читабельное имя google.com, а работа с ресурсом осуществляется с
помощью IP.

**I18N и L10N** - Internationalization и Localization соответственно. Разница в сокращенных буквах между ними. Это
адаптация программы для определенного региона.

**CI/CD (contitios integration and continiue delivery)** — концепция, которая реализуется как конвейер, облегчая слияние
только что закомиченного кода в основную кодовую базу. Концепция позволяет запускать различные типы тестов на каждом
этапе (цифровые сертификаты)

**SSL** — Secure Socket Layer, уровень защищенных сокетов.

**TLS** — Transport Layer Security, безопасность транспортного уровня.

**VNC (Virtual Network Computing, удаленное администрирование)** - VNC работает по принципу “клиент-сервер”, при котором
средство просмотра установлено на локальный компьютер, который подключен к удаленному компьютеру.

**VPN (Virtual Private Network — виртуальная частная сеть)** проще всего воспринимать как безопасный туннель между двумя
местами в сети.

**XML (Extensible Markup Language, Расширяемый язык разметки)** - уже почти не используется.

**JSON (JavaScript Object Notation)** - текстовый формат обмена данными, основанный на JavaScript. JSON требует меньше
кода и имеет меньший размер, что ускоряет обработку и передачу данных. Несмотря на то, что JSON написан на JavaScript,
он не зависит от языка. Благодаря популярности технологии API REST, JSON получил импульс в программировании кода API и
веб-сервисов.

**Двоичные данные** - они же байт код, они же бинарный, машинный код, это последовательность единиц и нулей.

**Cookies (куки)** - это такие файлы, которые хранятся в недрах нашего компьютера, они содержат разную информацию о
сайтах, которые Вы ранее посещали. Например, это могут быть поисковые запросы, теперь, когда вам снова нудна такая же
информация, поисковик вам просто предложит уже готовый вариант запроса. Или, например, вы заполняли какую-то анкету на
сайте и ушли, забыв ее отправить, в следующий раз при посещении этого сайта, cookie помогут вам возобновить информацию.

- Пары ключ-значение - у куки есть ряд настроек, которые должны быть установлены. Они указываются после пары
  ключ=значение и отделены друг от друга; (точкой с запятой). Куки можно создавать через JavaScript при помощи свойства
  document.cookie.
- Защита сессии через куки (php) - по умолчанию вся информация о сессии, включая ID, передается в cookie. Но так бывает
  не всегда. Некоторые пользователи отключают cookie в своих браузерах. В таком случае браузер будет передавать
  идентификатор сессии в URL. ID передается в открытом виде, в отличие от сессии через cookie, когда информация скрыта в
  HTTP-заголовке. Самым простым способом защиты от этого будет запрет передачи идентификатора сессии через адресную
  строку. Сделать это можно, прописав следующее в конфигурационном файле Apache-сервера .htaccess: (php_flag
  session.use_only_cookies on).

**Пользовательская сессия** – это промежуток времени, охватывающий работу пользователя в интернете с момента открытия
первой и до последней ссылок.

**Кэш (cache)** - кеширование – это сохранение тех данных, которые хранятся где-то «далеко», в каком-то месте «поближе».
Например, веб-страничка хранится где-то в интернете, а браузер может временно закешировать её прямо на телефоне, чтобы
если вы решите её снова открыть, она уже была под рукой и не надо было её заново скачивать. Или, скажем, данные
Яндекс.Карт – приложение кеширует их, чтобы когда вы оказались посреди леса без интернета, всё равно можно было бы
узнать, куда идти.

**Кешированные данные**, несомненно, можно удалять, т.к. «оригинал» хранится где-то в другом месте, и когда данные
понадобятся, телефон просто скачает их заново.

**Хэш (Hash)** - хэш-функции – это функции, предназначенные для «сжатия» произвольного сообщения или набора данных,
записанных, как правило, в двоичном алфавите, в некоторую битовую комбинацию фиксированной длины, называемую сверткой.
Хэш-функции имеют разнообразные применения при проведении статистических экспериментов, при тестировании логических
устройств, при построении алгоритмов быстрого поиска и проверки целостности записей в базах данных. Основным требованием
к хэш-функциям является равномерность распределения их значений при случайном выборе значений аргумента.

**Криптографической хэш-функцией** - называется всякая хеш-функция, являющаяся криптостойкой, то есть удовлетворяющая
ряду требований специфичных для криптографических приложений. В криптографии хэш-функции применяются для решения
следующих задач:

- построения систем контроля целостности данных при их передаче или хранении,
- аутентификация источника данных.

**Методы:** Message Digest 5 (MD5), Secure Hashing Algorithm (SHA).

- Request – это запрос серверу.
- Response – это ответ сервера. (даёт ответ после запроса request).

HTTP-протокол состоит только из текста. Ну а нас больше всего интересует структура, в которой расположен этот текст.
Каждое сообщение состоит из трех частей:

1. Стартовая строка (Starting line) — определяет служебные данные.
2. Заголовки (Headers) — описание параметров сообщения.
3. Тело сообщения (Body) — данные сообщения. Должны отделяться от заголовков пустой строкой.

По HTTP-протоколу можно отправить запрос на сервер (request) и получить ответ от сервера (response). Запросы и ответы
немного отличаются параметрами.

**HTTP-заголовки:**

- **General Headers (Общие заголовки)** — используются в запросах и ответах.
- **Request Headers (Заголовки запроса)** — используются только в запросах.
- **Response Headers (Заголовки ответа)** — используются только в ответах.
- **Entity Headers (Заголовки сущности)** — сопровождают каждую сущность сообщения. Используются в запросах и ответах.
- **Accept** – http заголовок запроса Accept указывает, какие типы контента, выраженные как MIME типы(Медиа-тип,
  является стандартом, описывает формат документа, файлов, байтов), клиент может понять. Используя согласование
  контента, сервер затем выбирает одно из предложений, использует его и информирует клиента о своем выборе с помощью
  заголовка ответа Content-type.

## 15. HTTP-ОТВЕТЫ, КОДЫ ОШИБОК

**Список ошибок http (хх – любые цифры):**

**2хх** — запрашиваемый запрос выполнен;

**3хх** — запрашиваемый запрос отправлен пользователю, тоже считается положительным кодом;

**4хх** — файл не был отправлен пользователю по причине ошибки. Этот код означает ошибку со стороны клиента;

**5хх** — ошибка сервера.

**Ошибка 400 «Bad Request»**

Если при запросе к сайту, вы получаете ошибку 400, значит в самом запросе допущена ошибка. Но такая ошибка может
возникнуть, если вы пытаетесь войти в панель управления вашего сайта. Чаще всего это случается по 4 причинам:

- браузер заблокирован антивирусом;
- браузер заблокирован брэндмауэром Windows;
- большое количество cookies и файлов в кэше;
- нестабильное подключение к интернету.

**Ошибка 403 «Доступ запрещен»**

Если ответ сервера – ошибка 403, значит, что доступ к запрашиваемым файлам запрещен. Самые часто встречающиеся причины:

Некорректный индексный файл. Для исправления этой ошибки нужно создать такой файл или переименовать, если он уже
имеется.

Права доступа файла не дают веб-серверу его прочесть. Для решения проблемы нужно изменить права.

Данные расположены в неверной директории. Для решения проверьте нахождение файлов в директории public_html.

**Ошибка 404 – файл не найден**

Такая ошибка означает, что сервер не находит данные по запросу. Основные причины ее возникновения:

URL введен некорректно. Чтобы устранить ошибку, проверьте правильность написания ссылки.

Запрашиваемый документ отсутствует. Чтобы устранить ошибку, нужно проверить, находится ли запрашиваемый файл в нужной
директории.

**Ошибка 500 – ошибка сервера**

Чтобы узнать, что значит ошибка http с кодом 500, нужно проверить причины ее возникновения.

Невозможность запуска скрипта. Если на документы указаны неверные права доступа, такие как 777, работа скриптов с этими
файлами блокируется сервером. Чтобы устранить данную проблему, необходимо установить корректные права доступа к файлам.

Ошибка в файле .htaccess. Возможно, ошибка в директиве. Чтобы устранить ошибку, включите error.log.

**Ошибка 502 – Bad Gateaway**

Такие статусы ошибок http, как 502, сообщают о том, сервер дал недопустимый ответ. Причины появления такой ошибки:

Прокси-сервер работает неисправно. Убедитесь, что у вас есть доступ в сеть. Если доступ к другим сайтам имеется и
интернет работает, удалите куки и очистите кэш.

Недостаточность серверных ресурсов. Такая проблема может возникнуть, если ваш сайт превышает количество ресурсов,
выделяемое вам хостингом на данном тарифном плане. Изучите тарифы хостинга и выберите себе более подходящий,
предоставляющий больше ресурсов.

**Ошибка 503 – Service Temporarily Unavailable**

Каждый сайт, располагаясь на хостинге, имеет в распоряжении ограниченное количество рабочих процессов в зависимости от
тарифа. Процессы выполняются по очереди и, чем больше процессов, тем сильнее забивается очередь, количество процессов в
которой ограничено. Таким образом, если процесс не вмещается в установленный объем очереди, он не выполнятся. При этом
сервер выдает ошибку «Сервис временно недоступен». Причины появления ошибки:

Ограниченность времени работы скрипта. Так как через некоторое время скрипты прекращают свою работу, они могут не успеть
передать большой файл. Чтобы устранить эту ошибку, отключите все плагины по очереди, выявляя из их числа самые тяжелые.
Виновника следует заменить на аналогичный плагин или же отказаться от него вовсе.

## 16. МЕТОДЫ. HTTP-ЗАПРОСЫ (REST)

**GET** – (получить) запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать
данные.

**HEAD** - запрашивает ресурс так же, как и метод GET, но без тела ответа.

**POST** - (создание) используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния
или какие-то побочные эффекты на сервере.

**PUT** – (обновляет) заменяет все текущие представления ресурса данными запроса.

**DELETE** - удаляет указанный ресурс.

**CONNECT** - устанавливает "туннель" к серверу, определённому по ресурсу.

**OPTIONS** - используется для описания параметров соединения с ресурсом.

**TRACE** - выполняет вызов возвращаемого тестового сообщения с ресурса.

**PATCH** - используется для частичного изменения ресурса.

**Flash** - мультимедиа технология для сети Интернет. Флэш работает с векторной графикой и растровой графикой, а с
выходом Flash 4 появилась возможность создания интерактивных приложений. Сама же технология Flash появилась в 1996 г., а
русскоязычная часть сети стала обрастать примерами Flash с 1997 г.

Программы для работы с API: SoapUI, Postman, Katalon Studio, Tricentis Tosca, Apigee

## 17. REST И SOAP

**API** — это специальный интерфейс программы или приложения (библиотеки классов и процедур), с помощью которого одна
программа/приложение может взаимодействовать с другой. С помощью API различные программы и приложения могут использовать
функции и ресурсы друг друга. Это своего рода "язык программ", на котором они разговаривают и обмениваются данными и
информацией.

**SOAP и REST** - позволяют создавать собственный API. API означает интерфейс прикладного программирования. Это
позволяет передавать данные из приложения в другие приложения. API получает запросы и отправляет ответы через
интернет-протоколы, такие как HTTP, SMTP и другие. Многие популярные веб-сайты предоставляют общедоступные
API-интерфейсы для своих пользователей, например, Google Maps имеет общедоступный REST API, который позволяет
настраивать Google Maps с вашим собственным контентом. Есть также много API, которые были созданы компаниями для
внутреннего использования.

**SOAP и REST** — это два стиля API, которые подходят к вопросу передачи данных с другой точки зрения. SOAP — это
стандартизированный протокол, который отправляет сообщения с использованием других протоколов, таких как HTTP и SMTP.

**SOAP** это протокол обмена структурированными XML сообщениями в произвольной распределенной вычислительной среде.
Отсюда следует, что мы должны куда-то передать XML и получить назад также XML. Для передачи нам нужен транспорт. Или
протокол передачи данных. Например SMTP, FTP, HTTP, HTTPS. Чаще всего HTTP.

**Программа: SoapUI**

**XML-файл состоит из следующих частей:**

1. **Конверт (обязательно)** — это начальный и конечный теги сообщения.
2. **Заголовок (необязательно)** — содержит необязательные атрибуты сообщения. Это позволяет расширять сообщение SOAP
   модульным и децентрализованным способом.
3. **Тело (обязательно)** — содержит данные XML, которые сервер передает получателю.
4. **Неисправность (необязательно)** — содержит информацию об ошибках, возникших при обработке сообщения.

**Плюсы SOAP:**

- Описание имеет чёткую структуру.
- Автоматическая валидация.
- Проверка данных осуществляется soap-сервером.
- Авторизация и аутенфикация может быть реализована отдельны методом.

**Минусы SOAP:**

- Большой размер сообщений (из-за структуры xml-сообщений).
- Автоматическая смена описания веб-сервера может сломать клиенты.
- Бывает сложно разбираться с описанием всё ли правильно у сервера/клиента.
- Ошибки далеки для понимания пользователя.

**WSDL (Web Services Description Language)** - правила, по которым составляются сообщения для веб-сервиса описываются
так же с помощью xml и также имеют четкую структуру.

**JMeter** – это настольное приложение Java с открытым исходным кодом, предназначенное для проведения тестирования
нагрузки и измерения производительности.

**REST (Representational State Transfer, передача состояния представления, Рой Филдинг, один из создателей протокола
HTTP)** — это архитектура, т.е. принципы построения распределенных гипермедиа систем, того что другими словами
называется World Wide Web, включая универсальные способы обработки и передачи состояний ресурсов по HTTP.

**Программа: Postman**.

Чтобы создать REST API, необходимо соблюдать шесть архитектурных ограничений:

1. **Унифицированный интерфейс** — запросы от разных клиентов должны выглядеть одинаково, например, один и тот же ресурс
   не должен иметь более одного URI.
2. **Разделение клиент-сервер** — клиент и сервер должны действовать независимо друг от друга. Они должны
   взаимодействовать друг с другом только через запросы и ответы.
3. **Безгражданство** — не должно быть никаких сеансов на стороне сервера. Каждый запрос должен содержать всю
   информацию, которую сервер должен знать.
4. **Кэшируемые ресурсы** — ответы сервера должны содержать информацию о том, кэшируются ли отправляемые ими данные или
   нет. Кэшируемые ресурсы должны поступать с номером версии, чтобы клиент мог не запрашивать одни и те же данные более
   одного раза.
5. **Многоуровневая система**. Между клиентом и сервером, который возвращает ответ, может быть несколько уровней
   серверов. Это не должно влиять ни на запрос, ни на ответ.
6. **Код по запросу [необязательно]** — когда это необходимо, ответ может содержать исполняемый код (например,
   JavaScript в ответе HTML), который может выполнить клиент.

**Плюсы REST:**

- Отсутствие дополнительных внутренних прослоек, что означает передачу данных в том же виде, что и сами данные. Т.е.
  данные не оборачиваются в XML, как это делает SOAP и XML-RPC, не используется AMF, как это делает Flash и т.д. Просто
  отдаются сами данные.
- Каждая единица информации (ресурс) однозначно определяется URL — это значит, что URL по сути является первичным ключом
  для единицы данных. Причем совершенно не имеет значения, в каком формате находятся данные по адресу — это может быть и
  HTML, и jpeg, и документ Microsoft Word.
- Как происходит управление информацией ресурса — это целиком и полностью основывается на протоколе передачи данных.
  Наиболее распространенный протокол конечно же HTTP. Для HTTP действие над данными задается с помощью методов: GET (
  получить), PUT (добавить, заменить), POST (добавить, изменить, удалить), DELETE (удалить). Таким образом, действия
  CRUD (Create-Read-Update-Delete) могут выполняться как со всеми 4-мя методами, так и только с помощью GET и POST.

**Используем REST:**

- Когда есть ограничение пропускной способности соединения.
- Если необходимо кэшировать запросы.
- Если система предполагает значительное масштабирование.

**CRUD (Create-Read-Update-Delete)** - Создание, чтение, модификация и удаление.

**RESTful** - Чтобы распределенная система считалась сконструированной по REST архитектуре (ЭТО API, которое действует
по соглашениям REST). (Restful)

1. **Client-Server**. Система должна быть разделена на клиентов и на серверов.
2. **Stateless**. Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая
   информация для обработки запроса и если необходимо, идентификации клиента.
3. **Cache**․ Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного
   использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.
4. **Uniform Interface**. Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет
   архитектуру, которая позволяет каждой части развиваться самостоятельно.

## 18. SOAP VS REST

**«REST vs SOAP»** можно перефразировать в «Простота vs Стандарты», что проявляется в том, что для SOAP мы имеем
протокол WSDL для исчерпывающего описания веб-сервиса, который с использованием все тех же чудесных средств разработки
прото-таки волшебным образом делает почти всю работу за нас. Со стороны REST мы имеем загадочный и неиспользуемый
протокол WADL, который, в принципе, и не нужен – он мешает простоте.

**Обработка ошибок** - в SOAP она полностью стандартизована, а REST может использовать давно известные коды ошибок HTTP.

**SOAP работает с операциями, а REST – с ресурсами.** Этот факт в совокупности с отсутствием клиентского состояния у
RESTful сервисов приводит нас к тому, что такие вещи как транзакции или другая сложная логика должна реализовываться
«SOAP-но».

**Факты:**

1. **REST** ничего не изобрел, а просто собрал в одну диссертацию то, что уже существовало в каком-то виде и изложил то,
   как можно получать максимальную выгоду из уже сформировавшейся архитектуры сети.
2. **SOAP и REST** – не конкуренты. Они представляют разные весовые категории и вряд ли найдется задача, для которой
   будет сложно сказать, какой подход рациональнее использовать – SOAP или REST. Поэтому «религиозные» убеждения в
   вопросах выбора архитектуры для веб-сервиса вряд ли будут полезны. Для тех, кто не знает, с чего начать анализ
   задачи, могу порекомендовать эту презентацию. У них чаще побеждает REST.

## 19. ИНСТРУМЕНТЫ

**Багтрекер** – это система отслеживания ошибок. Прикладная программа, разработанная с целью помочь разработчикам
программного обеспечения.

**Примеры:**

- Jira Enterprise Mail Handler
- YouTrack

**Система управления тестами** - база, где хранятся тест-кейсы, чек-листы, можно заводить тест-кейсы, там может
храниться база тестов в одном месте. Позволяет управлять процессом написания тест-кейсов. (управление статусами
тест-кейсов, сложность, приоритет). Потом тест-кейсы удобно прогонять, формирования тест-кейсы и отслеживать.

**Примеры:**

- Qase
- Adaptivista (c Jira)
- Test link
- TestRail

**JIRA** – инструмент для ведения проекта, учета задач и багов.
**Confluence** – инструмент для документации.

## 20. БАЗЫ ДАННЫХ

**СУБД (система управления базами данных)** - совокупность программных и лингвистических средств общего или специального
назначения, обеспечивающих управление созданием и использованием баз данных.

**СУБД хранит данные** - основными единицами физического хранения являются блок данных, экстент, файл (либо раздел
жесткого диска). Логический уровень представления информации включает пространства (либо табличные пространства). Блок
данных (block) или страница (page) является единицей обмена с внешней памятью. Размер страницы фиксирован для базы
данных (Oracle) или для ее различных структур (DB2, Informix, Sybase) и устанавливается при создании.

**СУБД содержит:**

- Ядро (которое отвечает за управление данными во внешней и оперативной памяти и журнализацию).
- Процессор языка (обеспечивающий оптимизацию запросов на извлечение и изменение данных и создание, как правило,
  машинно-независимого исполняемого внутреннего кода).
- Подсистему поддержки времени исполнения (интерпретирует программы манипуляции данными, создающие пользовательский
  интерфейс с СУБД)
- Сервисные программы ((внешние утилиты), обеспечивающие ряд дополнительных возможностей по обслуживанию информационной
  системы).

**Модели БД:**

- Иерархические (Используется представление базы данных в виде древовидной (иерархической) структуры, состоящей из
  объектов (данных) различных уровней).
- Сетевые (Сетевые базы данных подобны иерархическим, за исключением того, что в них имеются указатели в обоих
  направлениях, которые соединяют родственную информацию).
- Реляционные (база данных, основанная на реляционной(отношения, зависимость, связь), модели данных).
- Объектно-ориентированные (Управляют базами данных, в которых данные моделируются в виде объектов, их атрибутов,
  методов и классов. Этот вид СУБД позволяет работать с объектами баз данных так же, как с объектами в программировании
  в объектно-ориентированных языках программирования. ООСУБД расширяет языки программирования, прозрачно вводя
  долговременные данные, управление параллелизмом, восстановление данных, ассоциированные запросы и другие возможности).

**SQL (Structured Query Language)** - Язык структурированных запросов.

**MySQL** – программа, понимающая SQL.

**NoSQL** (Базы данных) специально созданы для определенных моделей данных и обладают гибкими схемами, что позволяет
разрабатывать современные приложения. Базы данных NoSQL получили широкое распространение в связи с простотой разработки,
функциональностью и производительностью при любых масштабах.

**SQL** – структурированные, изолированные. NoSQL – масштабируемость и быстродействие.

**Команды:**

**JOIN** - присоединение таблиц в запросах.

**INNER JOIN** – Внутреннее присоединение. Равносильно JOIN или CROSS JOIN.

**OUTER JOIN** – внешнее присоединение. Различают OUTER JOIN и RIGHT OUTER JOIN, и обычно опускают слово OUTER. Внешнее
присоединение включает в себя результаты запроса INNER и добавляются «неиспользованные» строки из одной из таблиц. Какую
таблицу использовать в качестве «добавки» — указывает токен LEFT или RIGHT.

**LEFT JOIN** – внешнее присоединение слева.

**RIGHT JOIN** – внешнее присоединение справа.

**Группировка:**

**GROUP BY и HAVING** - позволяют сгруппировать данные. Они употребляются в рамках команды SELECT:

**GROUP BY** - определяет, как строки будут группироваться.

**HAVING** - позволяет выполнить фильтрацию групп, то есть определяет, какие группы будут включены в выходной результат.
Использование HAVING во многом аналогично применению WHERE. Только есть WHERE применяется для фильтрации строк, то
HAVING - для фильтрации групп.

**Агрегатные функции** - существуют для того, чтобы была возможность каким либо образом обобщить полученные данные, то
есть манипулировать ими так, как нам это захочется. Эти функции выполняются с помощью ключевых слов, которые включаются
в запрос SELECT, и о том, как они прописываются будет рассказано далее.

- COUNT – возвращает количество значений в указанном столбце;
- SUM– возвращает сумму значений в указанном столбце;
- AVG – возвращает усредненное значение в указанном столбце;
- MIN – возвращает минимальное значение в указанном столбце;
- МАХ – возвращает максимальное значение в указанном столбце.

## 21. КОМАНДЫ ТЕРМИНАЛОВ WINDOWS, LINUX

**BASH** — Bourne-Again SHell - самый популярный командный интерпретатор в юниксоподобных системах, в особенности в
Linux. (командная строка).

**Команды для управления файлами:**

**LS** - Утилита для просмотра содержимого каталогов. По умолчанию показывает текущий каталог. Если в параметрах указать
путь, то она перечислит содержимое конечного каталога. Полезные опции -l (List) и -a (All). Первая форматирует вывод в
виде списка с более подробной информацией, а вторая включает показ скрытых файлов.

**CAT** - Печатает содержимое файла, переданного в параметре, в стандартный вывод. Если передать несколько файлов,
команда склеит их. Также можно перенаправить вывод в ещё один файл с помощью символа '>'. Если нужно вывести только
определенное количество строк, используйте опцию -n (Number).

**CD** - Позволяет перейти из текущего каталога в указанный. Если запустить без параметров - возвращает в домашний
каталог. Вызов с двумя точками возвращает на уровень вверх относительно текущего каталога. Вызов с тира (cd -)
возвращает к предыдущему каталогу.

**PWD** - Печатает на экран текущий каталог. Это может быть полезно, если ваша командная строка Linux не выводит такую
информацию. Эта команда будет востребована в Bash программировании, где для получения ссылки на каталог выполняется
скрипт.

**MKDIR** - Создание новых каталогов. Наиболее удобная опция -p (Parents), позволяет создать всю структуру подкаталогов
одной командой, даже если они ещё не существуют.

**FILE** - Показывает тип файла. В Linux файлы не обязаны всегда иметь расширения для того, чтобы с ними работать.
Поэтому пользователю иногда трудно определить, что за файл перед ним. Эта маленькая утилита решает проблему.

**CP** - Копирование файлов и каталогов. Она не копирует каталоги по умолчанию рекурсивно (то есть все поддиректории и
все файлы в поддиректориях), поэтому не забудьте добавить опцию -r (Recursive) или -a (Archive). Последняя включает
режим сохранения атрибутов, владельца и временного штампа в дополнение к рекурсивному копированию.

**MV** - Перемещение или переименование файлов и каталогов. Примечательно, что в Linux это одна и та же операция.
Переименование — это перемещение файла в ту же папку с другим именем.

**RM** - Удаляет файлы и папки. Очень полезная команда Linux: с её помощью вы можете убрать весь беспорядок. Если нужно
рекурсивное удаление, используйте опцию -r. Однако будьте осторожны: конечно, для того чтобы повредить систему вам нужно
будет серьёзно постараться, однако можно удалить собственные важные файлы. Rm удаляет файлы не в корзину, из которой
потом всё можно будет восстановить, а полностью стирает. Действия оператора rm необратимы. Поверьте, ваши оправдания в
духе "rm съела мою курсовую" никому не будут интересны.

**LN** - Создает жёсткие или символические ссылки на файлы. Символические или программные ссылки — это что-то похожее на
ярлыки в Windows. Они предоставляют удобный способ доступа к определённому файлу. Символические ссылки указывают на
файл, но не имеют никаких метаданных. Жёсткие ссылки, в отличие от символических, указывают на физический адрес области
диска, где хранятся данные файла.

**CHMOD** - Изменяет права доступа к файлу. Это чтение, запись и выполнение. Каждый пользователь может изменять права
для своих файлов.

**CHOWN** - Изменяет владельца файла. Только суперпользователь может изменять владельцев. Для рекурсивного изменения
используйте опцию -R.

**FIND** - Поиск в файловой системе, файлах и папках. Это очень гибкая и мощная команда Linux не только из-за своих
способностей ищейки, но и благодаря возможности выполнять произвольные команды для найденных файлов.

**LOCATE** - В отличие от find, команда locate ведёт поиск в базе данных updatedb для шаблонов имён файлов. Эта база
данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадёжен, потому что вы не
можете быть уверены, что ничего не изменилось с момента последнего снимка.

**DU** - Показывает размер файла или каталога. Самые полезные опций: -h (Human), которая преобразует размеры файлов в
легко читаемый формат, -s (Summarize), которая выводит минимум данных, и -d (Depth), устанавливающая глубину рекурсии по
каталогам.

**DF** - Анализатор дискового пространства. По умолчанию вывод достаточно подробный: перечислены все файловые системы,
их размер, количество использованного и свободного пространства. Для удобства есть опция -h, делающая размеры легко
читаемыми.

**DD** - как сказано в официальном руководстве, это команда терминала для копирования и преобразования файлов. Не очень
понятное описание, но это всё, что делает dd. Вы передаёте ей файл-источник, пункт назначения и пару дополнительных
опций. Затем она делает копию одного файла в другой. Вы можете задать точный размер данных, которые нужно записать или
скопировать. Работает утилита со всеми устройствами. Например, если вы хотите перезаписать жёсткий диск нулями из
/dev/zero, можете сделать это. Также она часто используется для создания LiveUSB или гибридных ISO образов.

**MOUNT/UMOUNT** — Это команды консоли Linux для подключения и отключения файловых систем Linux. Можно подключать всё:
от USB накопителей, до ISO образов. И только у суперпользователя есть права для этого.

**Команды для работы с текстом:**

**MORE / LESS** — Это две простенькие команды терминала для просмотра длинных текстов, которые не вмещаются на одном
экране. Представьте себе очень длинный вывод команды. Или вы вызвали cat для просмотра файла, и вашему эмулятору
терминала потребовалось несколько секунд, чтобы прокрутить весь текст. Если ваш терминал не поддерживает прокрутки, вы
можете сделать это с помощью less. Less новее, чем more и поддерживает больше опций, поэтому использовать more нет
причин.

**HEAD / TAI**L - у каждой команды своя область применения. Head выводит несколько первых строк из файла (голова), а
tail выдает несколько последних строк (хвост). По умолчанию каждая утилита выводит десять строк. Но это можно изменить с
помощью опции -n. Ещё один полезный параметр -f, это сокращение от follow (следовать). Утилита постоянно выводит
изменения в файле на экран. Например, если вы хотите следить за лог файлом, вместо того, чтобы постоянно открывать и
закрывать его, используйте команду tail -nf.

**GREP** - как и другие инструменты Linux, делает одно действие, но делает его хорошо: она ищет текст по шаблону. По
умолчанию она принимает стандартный ввод, но вы можете искать в файлах. Шаблон может быть строкой или регулярным
выражением. Она может вывести как совпадающие, так и не совпадающие строки, и их контекст. Каждый раз, когда вы
выполняете команду, которая выдает очень много информации, не нужно анализировать всё вручную - пусть grep делает свою
магию.

**SORT** - Сортировка строк текста по различным критериям. Наиболее полезные опции: -n (Numeric), по числовому значению,
и -r (Reverse), которая переворачивает вывод. Это может быть полезно для сортировки вывода du. Например, если хотите
отсортировать файлы по размеру, просто соедините эти команды.

**WC** - Утилита командной строки Linux для подсчёта количества слов, строк, байт и символов.

**DIFF** - Показывает различия между двумя файлами в построчном сравнении. Причём выводятся только строки, в которых
обнаружены отличия. Измененные строки отмечаются символом "с", удалённые - "d", а новые - "а".

**Команды для управления процессами:**

**KILL / XKILL / PKILL / KILLALL** - Служат для завершения процессов. Но они принимают различные параметры для
идентификации процессов. Kill нужен PID процесса, xkill - достаточно кликнуть по окну, чтобы закрыть его, killall и
pkill принимают имя процесса. Используйте ту, которая удобна в определенной ситуации.

**PS / PGREP** - Как уже говорилось, чтобы уничтожить процесс, нужен его идентификатор. Один из способов получить его,
это утилита ps, которая печатает информацию о запущенных процессах. По умолчанию вывод очень длинный, поэтому
используйте опцию -e, чтобы увидеть информацию об определённом процессе. Это только снимок состояния на момент вызова, и
информация не будет обновляться. Команда ps с ключом aux выводит полную информацию о процессах. Pgrep работает следующим
образом: вы задаете имя процесса, а утилита показывает его идентификатор.

**TOP / HTOP** - Обе команды похожи, обе отображают процессы и могут быть использованы как консольные системные
мониторы. Я рекомендую установить htop, если в вашем дистрибутиве он не поставляется по умолчанию, так как это
улучшенная версия top. Вы сможете не только просматривать, но и контролировать процессы через его интерактивный
интерфейс.

**TIME** - Время выполнения процесса. Это секундомер для выполнения программы. Полезно, если вам интересно, насколько
сильно ваша реализация алгоритма отстает от стандартной. Но, несмотря на такое название, она не сообщит вам текущее
время, используйте для этого команду date.

**Команды для окружения пользователя:**

**SU / SUDO** — это два способа выполнить одну и ту же задачу: запустить программу от имени другого пользователя. В
зависимости от вашего дистрибутива вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su
переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет
наиболее безопасным вариантом работы.

**DATE** - В отличие от time, делает именно то, чего вы от неё и ожидаете: выводит дату и время в стандартный вывод. Его
можно форматировать в зависимости от ваших потребностей: вывести год, месяц, день, установить 12-ти или 24-ти часовой
формат, получить наносекунды или номер недели. Например, date +"%j %V", выведет день в году и номер недели в формате
ISO.

**ALIAS** - Команда создаёт синонимы для других команд Linux. То есть вы можете делать новые команды или группы команд,
а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или
создания более понятных имен для команд, которые вы используете нечасто и не можете запомнить.

**UNAME** - Выводит некую основную информацию о системе. Без параметров она не покажет ничего полезного, кроме строчки
Linux, но, если задать параметр -a (All), можно получить информацию о ядре, имени хоста и узнать архитектуру процессора.

**UPTIME** - Сообщает вам время работы системы. Не очень существенная информация, но может быть полезна для случайных
вычислений или просто ради интереса, чтобы узнать, как давно был перезагружен сервер.

**SLEEP** - Вам, наверное, интересно как же её можно использовать. Даже не учитывая Bash-скриптинг, у неё есть свои
преимущества. Например, если вы хотите выключить компьютер через определенный промежуток времени или использовать в
качестве импровизированной тревоги.

**Команды для управления пользователями:**

**USERADD / USERDEL / USERMOD** - Эти команды консоли Linux позволяют вам добавлять, удалять и изменять учетные записи
пользователей. Скорее всего, вы не будете использовать их очень часто. Особенно если это домашний компьютер, и вы
являетесь единственным пользователем. Управлять пользователями можно и с помощью графического интерфейса, но лучше знать
об этих командах на всякий случай.

**PASSWD** - Эта команда позволяет изменить пароль учетной записи пользователя. Как суперпользователь вы можете сбросить
пароли всех пользователей, даже несмотря на то, что не можете их увидеть. Хорошая практика безопасности - менять пароль
почаще.

**Команды для просмотра документации:**

**MAN / WHATIS** - Команда man открывает руководство по определённой команде. Для всех основных команд Linux есть man
страницы. Whatis показывает, какие разделы руководств есть для данной команды.

**WHEREIS** - Показывает полный путь к исполняемому файлу программы. Также может показать путь к исходникам, если они
есть в системе.

**Команды для управления сетью:**

**IP** - Если список команд Linux для управления сетью вам кажется слишком коротким, скорее всего вы не знакомы с
утилитой ip. В пакете net-tools содержится множество других утилит: ipconfig, netstat и прочие устаревшие, вроде
iproute2. Всё это заменяет одна утилита - ip. Вы можете рассматривать её как швейцарский армейский нож для работы с
сетью или как непонятную массу, но в любом случае за ней будущее. Просто смиритесь с этим.

**PING** — это ICMP ECHO_REQUEST дейтаграммы, но на самом деле это неважно. Важно то, что утилита ping может быть очень
полезным диагностическим инструментом. Она поможет быстро проверить, подключены ли вы к маршрутизатору или к интернету,
и дает кое-какое представление о качестве этой связи.

**NETHOGS** - Если у вас медленный интернет, то вам, наверное, было бы интересно знать, сколько трафика использует
какая-либо программа в Linux или какая программа потребляет всю скорость. Теперь это можно сделать с помощью утилиты
nethogs. Для того чтобы задать сетевой интерфейс используйте опцию -i.

**TRACEROUTE** — Это усовершенствованная версия ping. Мы можем увидеть не только полный маршрут сетевых пакетов, но и
доступность узла, а также время доставки этих пакетов на каждый из узлов.
